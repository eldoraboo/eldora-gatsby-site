{"version":3,"file":"gatsby-node.js","sources":["../src/types.ts","../src/gatsby-node.ts"],"sourcesContent":["import { PluginOptions as GatsbyPluginOptions, NodeInput, Node } from 'gatsby'\nimport { CreateOptions as FlexSearchCreateOptions } from 'flexsearch'\n\nexport interface PartialContext {\n  nodeModel: {\n    getNodeById: (input: { id: string; type?: string }) => Node\n  }\n}\n\nexport type IndexableDocument = Record<string, unknown>\n\nexport type Store = Record<string, unknown>\n\nexport enum NodeType {\n  LocalSearch = 'LocalSearch',\n}\n\nexport type Engine = 'flexsearch' | 'lunr'\n\nexport interface LocalSearchNodeInput extends NodeInput {\n  name: string\n  engine: Engine\n  index: string\n  store: Store\n}\n\ninterface NormalizerInput {\n  errors?: unknown\n  data?: unknown\n}\n\nexport interface PluginOptions extends GatsbyPluginOptions {\n  name: string\n  engine: Engine\n  engineOptions?: FlexSearchCreateOptions\n  ref?: string\n  index?: string[]\n  store?: string[]\n  query: string\n  normalizer: (input: NormalizerInput) => IndexableDocument[]\n}\n","import path from 'path'\nimport fs from 'fs'\nimport lunr from 'lunr'\nimport FlexSearch from 'flexsearch'\nimport {\n  GatsbyNode,\n  CreatePagesArgs,\n  CreateSchemaCustomizationArgs,\n} from 'gatsby'\nimport { pick } from 'lodash'\nimport { pascalCase } from 'pascal-case'\n\nimport {\n  IndexableDocument,\n  NodeType,\n  PluginOptions,\n  Store,\n  LocalSearchNodeInput,\n} from './types'\n\nconst DEFAULT_REF = 'id'\n\nconst msg = (input: string) => `gatsby-plugin-local-search - ${input}`\n\nconst createFlexSearchIndexExport = (\n  documents: IndexableDocument[],\n  pluginOptions: PluginOptions,\n): string => {\n  const { ref = DEFAULT_REF, index: indexFields, engineOptions } = pluginOptions\n\n  const index = FlexSearch.create<IndexableDocument>(engineOptions)\n\n  documents.forEach((doc) => {\n    const serializedDoc = JSON.stringify(\n      indexFields ? pick(doc, indexFields) : doc,\n    )\n    // Using \"as number\" due to FlexSearch's types, but it could technically be\n    // a string as well.\n    index.add(doc[ref] as number, serializedDoc)\n  })\n\n  return index.export()\n}\n\nconst createLunrIndexExport = (\n  documents: IndexableDocument[],\n  pluginOptions: PluginOptions,\n): string => {\n  const { ref = DEFAULT_REF, index: indexFields } = pluginOptions\n\n  const fields =\n    indexFields ?? (documents.length > 0 ? Object.keys(documents[0]) : [])\n\n  const index = lunr(function () {\n    this.ref(ref)\n    fields.forEach((field) => this.field(field))\n    documents.forEach((doc) => this.add(doc))\n  })\n\n  return JSON.stringify(index)\n}\n\nconst createIndexExport = (\n  documents: IndexableDocument[],\n  pluginOptions: PluginOptions,\n  gatsbyContext: CreatePagesArgs,\n): string | void => {\n  const { reporter } = gatsbyContext\n  const { name, engine } = pluginOptions\n\n  switch (engine) {\n    case 'flexsearch':\n      return createFlexSearchIndexExport(documents, pluginOptions)\n\n    case 'lunr':\n      return createLunrIndexExport(documents, pluginOptions)\n\n    default:\n      reporter.error(\n        msg(\n          `The engine option for index \"${name}\" is invalid. It must be one of: flexsearch, lunr. The index will not be created.`,\n        ),\n      )\n  }\n}\n\n// Callback style is necessary since createPages cannot be async or return a\n// Promise. At least, that's what GatsbyNode['createNodes'] says.\nexport const createPages = async (\n  gatsbyContext: CreatePagesArgs,\n  pluginOptions: PluginOptions,\n): Promise<void> => {\n  const {\n    actions,\n    graphql,\n    reporter,\n    createNodeId,\n    createContentDigest,\n  } = gatsbyContext\n  const { createNode } = actions\n  const {\n    name,\n    engine,\n    ref = DEFAULT_REF,\n    store: storeFields,\n    query,\n    normalizer,\n  } = pluginOptions\n\n  const result = await graphql(query)\n\n  if (result.errors) {\n    reporter.error(\n      msg(\n        'The provided GraphQL query contains errors. The index will not be created.',\n      ),\n      result.errors[0],\n    )\n    return\n  }\n\n  const documents = (await Promise.resolve(normalizer(result))) || []\n\n  if (documents.length < 1)\n    reporter.warn(\n      msg(\n        `The query for index \"${name}\" returned no nodes. The index and store will be empty.`,\n      ),\n    )\n\n  const filteredDocuments = documents.filter(\n    (doc) => doc[ref] !== undefined && doc[ref] !== null,\n  )\n\n  const index = createIndexExport(\n    filteredDocuments,\n    pluginOptions,\n    gatsbyContext,\n  )\n  if (!index) return\n\n  const store = filteredDocuments.reduce((acc, doc) => {\n    acc[String(doc[ref])] = storeFields ? pick(doc, storeFields) : doc\n\n    return acc\n  }, {} as Store)\n\n  const nodeType = pascalCase(`${NodeType.LocalSearch} ${name}`)\n  const nodeId = createNodeId(name)\n\n  const node: LocalSearchNodeInput = {\n    id: nodeId,\n    name,\n    engine,\n    index,\n    store,\n    internal: {\n      type: nodeType,\n      contentDigest: createContentDigest({ index, store }),\n    },\n  }\n\n  createNode(node)\n}\n\nexport const createSchemaCustomization: NonNullable<\n  GatsbyNode['createSchemaCustomization']\n> = async (\n  gatsbyContext: CreateSchemaCustomizationArgs,\n  pluginOptions: PluginOptions,\n) => {\n  const { actions, schema, reporter, pathPrefix } = gatsbyContext\n  const { createTypes } = actions\n  const { name } = pluginOptions\n\n  const nodeType = pascalCase(`${NodeType.LocalSearch} ${name}`)\n\n  createTypes([\n    schema.buildObjectType({\n      name: nodeType,\n      fields: {\n        name: {\n          type: 'String!',\n          description: 'The name of the index.',\n        },\n        engine: {\n          type: 'String!',\n          description: 'The search engine used to create the index.',\n        },\n        index: {\n          type: 'String!',\n          description: 'The search index created using the selected engine.',\n        },\n        store: {\n          type: 'JSON!',\n          description:\n            'A JSON object used to map search results to their data.',\n        },\n        publicIndexURL: {\n          type: 'String!',\n          description:\n            \"Save the index to the site's static directory and return a public URL to it.\",\n          resolve: (node: LocalSearchNodeInput) => {\n            const filename = `${node.internal.contentDigest}.index.txt`\n\n            const publicPath = path.join(\n              process.cwd(),\n              'public',\n              'static',\n              filename,\n            )\n\n            if (!fs.existsSync(publicPath))\n              fs.writeFile(publicPath, node.index, (err) => {\n                if (err)\n                  reporter.error(\n                    msg(\n                      `Could not save the index for \"${name}\" to ${publicPath}`,\n                    ),\n                  )\n              })\n\n            return `${pathPrefix}/static/${filename}`\n          },\n        },\n        publicStoreURL: {\n          type: 'String!',\n          description:\n            \"Save the store to the site's static directory and return a public URL to it.\",\n          resolve: (node: LocalSearchNodeInput) => {\n            const filename = `${node.internal.contentDigest}.store.json`\n\n            const publicPath = path.join(\n              process.cwd(),\n              'public',\n              'static',\n              filename,\n            )\n\n            if (!fs.existsSync(publicPath))\n              fs.writeFile(publicPath, JSON.stringify(node.store), (err) => {\n                if (err)\n                  reporter.error(\n                    msg(\n                      `Could not save the store for \"${name}\" to ${publicPath}`,\n                    ),\n                  )\n              })\n\n            return `${pathPrefix}/static/${filename}`\n          },\n        },\n      },\n      interfaces: ['Node'],\n    }),\n  ])\n}\n"],"names":["NodeType","msg","input","gatsbyContext","pluginOptions","reporter","createNodeId","createContentDigest","createNode","actions","name","engine","ref","storeFields","store","normalizer","graphql","query","result","errors","Promise","resolve","documents","length","warn","filteredDocuments","filter","doc","index","indexFields","FlexSearch","create","engineOptions","forEach","serializedDoc","JSON","stringify","pick","add","createFlexSearchIndexExport","fields","Object","keys","lunr","this","field","_this","createLunrIndexExport","error","createIndexExport","reduce","acc","String","nodeType","pascalCase","LocalSearch","node","id","internal","type","contentDigest","schema","pathPrefix","createTypes","buildObjectType","description","publicIndexURL","filename","publicPath","path","join","process","cwd","fs","existsSync","writeFile","err","publicStoreURL","interfaces"],"mappings":"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"}